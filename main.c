#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>

char arr4096[] = "1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456";

void diskWriteSpeed(int fd);
void diskReadSpeed(int src, int tar);
void copyMemoryBandwidth();

int main(int argc, const char * argv[]) {
    //必须要确定每次测试都是新建的测试文件，不然会导致速度过低或者过高
    int fd = open("buffer.txt", O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
    //硬盘写入测试
    diskWriteSpeed(fd);
    close(fd);
    
    int src_fd = open("buffer.txt", O_RDONLY);
    int tar_fd = open("buffertarget.txt", O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
    //硬盘读取测试
    diskReadSpeed(src_fd, tar_fd);
    close(src_fd);
    close(tar_fd);
    
    //未完成
    copyMemoryBandwidth();
    return 0;
}

#define N 1e3
void diskWriteSpeed(int fd) {
    clock_t start = clock();

    for (int i=0; i<N; i++) {
        write(fd, arr4096, 4096);
    }
    
    clock_t end = clock();
    float speed = 4096.0f*N/(end-start);

    printf("4K write speed: %f MB/s\n", speed);
}


#define BUFSIZE 4096*16

void diskReadSpeed(int src, int tar) {
    int n;
    clock_t start = clock();

    char buf[BUFSIZE];
    while ((n=read(src, buf, BUFSIZE)) > 0) {
        if (write(tar, buf, n) != n) {
            printf("write error");
        }
    }
    clock_t end = clock();
    float speed = 4096.0*N/(end-start);

    printf("4K read speed: %f MB/s\n", speed);
}


#define memSize 1e6
#define ITERATIONS 100

void copyMemoryBandwidth() {
    unsigned char *s_data = malloc(memSize);
    unsigned char *t_data = malloc(memSize);

    if (s_data == 0) {
      fprintf(stderr, "Not enough memory avaialable on host to run test!\n");
      exit(-1);
    }

    // 初始化了了memSize的内存
    for (int i = 0; i < memSize / sizeof(unsigned char); i++) {
        s_data[i] = (unsigned char)(i & 0xff);
    }

    struct timespec start;
    clock_gettime(CLOCK_REALTIME, &start);

    for (int i=0; i<ITERATIONS; i++) {
        memcpy(t_data, s_data, memSize);
    }
    struct timespec end;
    clock_gettime(CLOCK_REALTIME, &end);

    //单位是秒
    double duration = (double)(end.tv_nsec-start.tv_nsec)/((double) 1e9) + (double)(end.tv_sec-start.tv_sec);

    //乘2是因为是在内存内部进行计算，所以带宽是包含读写两部分的
    double speed = 2.0f * (double)memSize * (double)ITERATIONS / 1e9 / duration;

    printf("Memory bandwidth: %f GB/s\n", speed);

    free(s_data);
    free(t_data);
}
